// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";
import axios from "axios";

// shared/schema.ts
import { z } from "zod";
var emailSummarySchema = z.object({
  id: z.string(),
  from_address: z.string(),
  to_address: z.string(),
  subject: z.string().nullable(),
  received_at: z.number(),
  has_attachments: z.boolean().default(false),
  attachment_count: z.number().default(0)
});
var attachmentSchema = z.object({
  id: z.string(),
  filename: z.string(),
  content_type: z.string(),
  size: z.number()
});
var emailSchema = z.object({
  id: z.string(),
  from_address: z.string(),
  to_address: z.string(),
  subject: z.string().nullable(),
  received_at: z.number(),
  html_content: z.string().nullable(),
  text_content: z.string().nullable(),
  has_attachments: z.boolean().default(false),
  attachment_count: z.number().default(0),
  attachments: z.array(attachmentSchema).optional().default([])
});
var domainSchema = z.string();
var referralSchema = z.object({
  id: z.string(),
  referralCode: z.string(),
  createdAt: z.number(),
  referrals: z.number().default(0),
  bonusEmails: z.number().default(0)
});
var referralStatsSchema = z.object({
  totalReferrals: z.number(),
  bonusEmails: z.number(),
  referralCode: z.string()
});

// server/storage.ts
import { randomUUID } from "crypto";
var MemStorage = class {
  users;
  referrals;
  constructor() {
    this.users = /* @__PURE__ */ new Map();
    this.referrals = /* @__PURE__ */ new Map();
  }
  async getUser(id) {
    return this.users.get(id);
  }
  async getUserByUsername(username) {
    return Array.from(this.users.values()).find(
      (user) => user.username === username
    );
  }
  async createUser(insertUser) {
    const id = randomUUID();
    const user = { ...insertUser, id };
    this.users.set(id, user);
    return user;
  }
  async getReferral(sessionId) {
    return this.referrals.get(sessionId);
  }
  async createReferral(sessionId) {
    const referralCode = this.generateReferralCode();
    const referral = {
      id: sessionId,
      referralCode,
      createdAt: Date.now(),
      referrals: 0,
      bonusEmails: 0
    };
    this.referrals.set(sessionId, referral);
    return referral;
  }
  async getReferralByCode(code) {
    return Array.from(this.referrals.values()).find(
      (ref) => ref.referralCode === code
    );
  }
  async updateReferral(sessionId, referrals, bonusEmails) {
    let referral = this.referrals.get(sessionId);
    if (!referral) {
      referral = await this.createReferral(sessionId);
    }
    referral.referrals = referrals;
    referral.bonusEmails = bonusEmails;
    this.referrals.set(sessionId, referral);
    return referral;
  }
  generateReferralCode() {
    return "REF-" + Math.random().toString(36).substring(2, 10).toUpperCase();
  }
};
var storage = new MemStorage();

// server/routes.ts
import { z as z2 } from "zod";
var TEMP_MAIL_API = "https://api.barid.site";
var responseCache = /* @__PURE__ */ new Map();
function getCachedResponse(key) {
  const cached = responseCache.get(key);
  if (cached && Date.now() - cached.timestamp < cached.ttl) {
    return cached.data;
  }
  responseCache.delete(key);
  return null;
}
function setCachedResponse(key, data, ttlMs) {
  responseCache.set(key, { data, timestamp: Date.now(), ttl: ttlMs });
}
var emailParamSchema = z2.string().email();
var emailIdParamSchema = z2.string().min(1);
async function registerRoutes(app2) {
  const funnyMessages = [
    "Bete tera se na hopayega! \u{1F6E1}\uFE0F This server is protected by TEMPMAIL SHIELD",
    "teri himmat! Rate limited harder than your WiFi password \u{1F604}",
    "Hacker detected! But only amateurs try this. You're banned from cool club \u{1F6AB}",
    "SQL injection? More like SQL rejection! \u{1F602}",
    "Brute force attack? Brute force REJECTED! Go touch grass \u{1F331}",
    "DDoS? More like DoNotAttack-oS! \u{1F916}",
    "Your IP: flagged, logged, and laughed at \u{1F605}",
    "Keep trying... we're watching! \u{1F440} (jk, we're not, but IP is blocked)",
    "UNAUTHORIZED ACCESS DETECTED - Sending thoughts and prayers to your keyboard \u{1F480}"
  ];
  const getRandomFunnyMessage = () => funnyMessages[Math.floor(Math.random() * funnyMessages.length)];
  const suspiciousActivity = /* @__PURE__ */ new Map();
  const apiLimits = /* @__PURE__ */ new Map();
  app2.use("/api/", (req, res, next) => {
    const ip = req.ip || "unknown";
    const now = Date.now();
    const blocked = suspiciousActivity.get(ip);
    if (blocked && now < blocked.blockedUntil) {
      return res.status(429).json({
        error: getRandomFunnyMessage(),
        blockedUntil: Math.ceil((blocked.blockedUntil - now) / 1e3) + "s"
      });
    }
    const suspiciousPatterns = [
      /union.*select/i,
      /drop.*table/i,
      /insert.*into/i,
      /delete.*from/i,
      /\/\/|--|\*\//,
      /<script|javascript:/i,
      /eval\(|exec\(/i
    ];
    const queryString = JSON.stringify([req.query, req.body, req.params]);
    const isAttack = suspiciousPatterns.some((pattern) => pattern.test(queryString));
    if (isAttack) {
      let activity = suspiciousActivity.get(ip) || { strikes: 0, blockedUntil: 0 };
      activity.strikes++;
      const blockDurations = [6e4, 3e5, 18e5];
      const blockDuration = blockDurations[Math.min(activity.strikes - 1, blockDurations.length - 1)];
      activity.blockedUntil = now + blockDuration;
      suspiciousActivity.set(ip, activity);
      console.warn(`[SECURITY] Attack detected from ${ip} (strike ${activity.strikes}): ${queryString.substring(0, 100)}`);
      return res.status(403).json({ error: getRandomFunnyMessage() });
    }
    const limit = apiLimits.get(ip) || { count: 0, resetTime: now + 6e4 };
    if (now > limit.resetTime) {
      apiLimits.set(ip, { count: 1, resetTime: now + 6e4 });
      next();
    } else if (limit.count < 100) {
      limit.count++;
      apiLimits.set(ip, limit);
      next();
    } else {
      return res.status(429).json({ error: getRandomFunnyMessage() });
    }
  });
  app2.get("/api/domains", async (req, res) => {
    try {
      const cacheKey = "domains";
      const cached = getCachedResponse(cacheKey);
      if (cached) {
        res.set("Cache-Control", "public, max-age=3600, stale-while-revalidate=86400");
        res.set("X-Cache", "HIT");
        return res.json(cached);
      }
      const response = await axios.get(`${TEMP_MAIL_API}/domains`);
      if (response.data.success && Array.isArray(response.data.result)) {
        const domains = z2.array(domainSchema).parse(response.data.result);
        setCachedResponse(cacheKey, domains, 60 * 60 * 1e3);
        res.set("Cache-Control", "public, max-age=3600, stale-while-revalidate=86400");
        res.set("X-Cache", "MISS");
        res.json(domains);
      } else {
        res.status(500).json({ error: "Failed to fetch domains" });
      }
    } catch (error) {
      console.error("Error fetching domains:", error);
      if (axios.isAxiosError(error) && error.response) {
        res.status(error.response.status).json({ error: "Failed to fetch domains" });
      } else {
        res.status(500).json({ error: "Failed to fetch domains" });
      }
    }
  });
  app2.get("/api/inbox/:email", async (req, res) => {
    try {
      const email = decodeURIComponent(req.params.email);
      const validationResult = emailParamSchema.safeParse(email);
      if (!validationResult.success) {
        res.status(400).json({ error: "Invalid email address format" });
        return;
      }
      const response = await axios.get(`${TEMP_MAIL_API}/emails/${email}`);
      if (response.data.success && Array.isArray(response.data.result)) {
        const emails = z2.array(emailSummarySchema).parse(response.data.result);
        res.json(emails);
      } else {
        res.json([]);
      }
    } catch (error) {
      console.error("Error fetching inbox:", error);
      if (axios.isAxiosError(error) && error.response) {
        if (error.response.status === 404) {
          res.status(404).json({ error: "Inbox not found" });
        } else if (error.response.status >= 400 && error.response.status < 500) {
          res.status(error.response.status).json({ error: "Failed to fetch inbox" });
        } else {
          res.status(502).json({ error: "Upstream service error" });
        }
      } else {
        res.status(500).json({ error: "Failed to fetch inbox" });
      }
    }
  });
  app2.get("/api/email/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const validationResult = emailIdParamSchema.safeParse(id);
      if (!validationResult.success) {
        res.status(400).json({ error: "Invalid email ID" });
        return;
      }
      const response = await axios.get(`${TEMP_MAIL_API}/inbox/${id}`);
      if (response.data.success && response.data.result) {
        const email = emailSchema.parse(response.data.result);
        res.json(email);
      } else {
        res.status(404).json({ error: "Email not found" });
      }
    } catch (error) {
      console.error("Error fetching email:", error);
      if (axios.isAxiosError(error) && error.response) {
        if (error.response.status === 404) {
          res.status(404).json({ error: "Email not found" });
        } else {
          res.status(error.response.status).json({ error: "Failed to fetch email" });
        }
      } else {
        res.status(500).json({ error: "Failed to fetch email" });
      }
    }
  });
  app2.delete("/api/email/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const validationResult = emailIdParamSchema.safeParse(id);
      if (!validationResult.success) {
        res.status(400).json({ error: "Invalid email ID" });
        return;
      }
      const response = await axios.delete(`${TEMP_MAIL_API}/inbox/${id}`);
      if (response.data.success) {
        res.json({ success: true, message: "Email deleted successfully" });
      } else {
        res.status(500).json({ error: "Failed to delete email" });
      }
    } catch (error) {
      console.error("Error deleting email:", error);
      if (axios.isAxiosError(error) && error.response) {
        if (error.response.status === 404) {
          res.status(404).json({ error: "Email not found" });
        } else {
          res.status(error.response.status).json({ error: "Failed to delete email" });
        }
      } else {
        res.status(500).json({ error: "Failed to delete email" });
      }
    }
  });
  app2.delete("/api/inbox/:email", async (req, res) => {
    try {
      const email = decodeURIComponent(req.params.email);
      const validationResult = emailParamSchema.safeParse(email);
      if (!validationResult.success) {
        res.status(400).json({ error: "Invalid email address format" });
        return;
      }
      const response = await axios.delete(`${TEMP_MAIL_API}/emails/${email}`);
      if (response.data.success) {
        res.json({
          success: true,
          message: "All emails deleted successfully",
          deleted_count: response.data.result?.deleted_count || 0
        });
      } else {
        res.status(500).json({ error: "Failed to delete emails" });
      }
    } catch (error) {
      console.error("Error deleting all emails:", error);
      if (axios.isAxiosError(error) && error.response) {
        res.status(error.response.status).json({ error: "Failed to delete emails" });
      } else {
        res.status(500).json({ error: "Failed to delete emails" });
      }
    }
  });
  app2.get("/api/attachment/:emailId/:attachmentId", async (req, res) => {
    try {
      const { emailId, attachmentId } = req.params;
      const emailValidation = emailIdParamSchema.safeParse(emailId);
      const attachmentValidation = emailIdParamSchema.safeParse(attachmentId);
      if (!emailValidation.success || !attachmentValidation.success) {
        res.status(400).json({ error: "Invalid email or attachment ID" });
        return;
      }
      const response = await axios.get(
        `${TEMP_MAIL_API}/inbox/${emailId}/attachment/${attachmentId}`,
        { responseType: "stream" }
      );
      res.setHeader("Content-Type", response.headers["content-type"] || "application/octet-stream");
      res.setHeader("Content-Disposition", response.headers["content-disposition"] || `attachment; filename="attachment"`);
      response.data.pipe(res);
    } catch (error) {
      console.error("Error downloading attachment:", error);
      if (axios.isAxiosError(error) && error.response) {
        if (error.response.status === 404) {
          res.status(404).json({ error: "Attachment not found" });
        } else {
          res.status(error.response.status).json({ error: "Failed to download attachment" });
        }
      } else {
        res.status(500).json({ error: "Failed to download attachment" });
      }
    }
  });
  app2.get("/api/referral/create", async (req, res) => {
    try {
      const sessionId = req.query.sid || "anonymous";
      let referral = await storage.getReferral(sessionId);
      if (!referral) {
        referral = await storage.createReferral(sessionId);
      }
      res.json({
        referralCode: referral.referralCode,
        referrals: referral.referrals,
        bonusEmails: referral.bonusEmails
      });
    } catch (error) {
      console.error("Error creating referral:", error);
      res.status(500).json({ error: "Failed to create referral" });
    }
  });
  app2.get("/api/referral/stats", async (req, res) => {
    try {
      const sessionId = req.query.sid || "anonymous";
      let referral = await storage.getReferral(sessionId);
      if (!referral) {
        referral = await storage.createReferral(sessionId);
      }
      res.json({
        totalReferrals: referral.referrals,
        bonusEmails: referral.bonusEmails,
        referralCode: referral.referralCode
      });
    } catch (error) {
      console.error("Error getting referral stats:", error);
      res.status(500).json({ error: "Failed to get referral stats" });
    }
  });
  app2.post("/api/referral/claim/:code", async (req, res) => {
    try {
      const { code } = req.params;
      const referrer = await storage.getReferralByCode(code);
      if (!referrer) {
        res.status(404).json({ error: "Referral code not found" });
        return;
      }
      const newReferrals = referrer.referrals + 1;
      const newBonusEmails = referrer.bonusEmails + 50;
      await storage.updateReferral(referrer.id, newReferrals, newBonusEmails);
      res.json({ success: true, bonusEmails: 50 });
    } catch (error) {
      console.error("Error claiming referral:", error);
      res.status(500).json({ error: "Failed to claim referral" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path from "path";
import { createServer as createViteServer, createLogger } from "vite";
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    configFile: path.resolve(process.cwd(), "vite.config.ts"),
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path.resolve(
        process.cwd(),
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path.resolve(process.cwd(), "dist", "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath, {
    maxAge: "1y",
    etag: true,
    lastModified: true
  }));
  app2.use("*", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}

// server/index.ts
var app = express2();
app.use(express2.json({
  verify: (req, _res, buf) => {
    req.rawBody = buf;
  }
}));
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  res.set("X-Content-Type-Options", "nosniff");
  res.set("X-Frame-Options", "SAMEORIGIN");
  res.set("X-XSS-Protection", "1; mode=block");
  res.set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
  res.set("Referrer-Policy", "strict-origin-when-cross-origin");
  res.set("Permissions-Policy", "geolocation=(), microphone=(), camera=(), payment=()");
  res.set("X-Powered-By", "TempMail-Shield-Secure");
  const origin = req.headers.origin;
  if (origin && (origin.includes("localhost") || origin.includes("tempmail.org") || origin.includes("replit.dev"))) {
    res.set("Access-Control-Allow-Origin", origin);
  }
  res.set("Access-Control-Allow-Methods", "GET, OPTIONS");
  res.set("Access-Control-Allow-Headers", "Content-Type");
  res.set("Access-Control-Max-Age", "3600");
  res.set("Vary", "Accept-Encoding");
  const isDev = process.env.NODE_ENV === "development";
  if (!isDev) {
    const prodCSP = [
      "default-src 'self'",
      "script-src 'self' 'wasm-unsafe-eval' 'unsafe-inline' data: blob:",
      "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
      "font-src 'self' https://fonts.gstatic.com",
      "img-src 'self' data: https:",
      "connect-src 'self' https://api.barid.site https://fonts.googleapis.com https://fonts.gstatic.com",
      "frame-ancestors 'none'"
    ].join("; ");
    res.set("Content-Security-Policy", prodCSP);
  }
  if (req.path.startsWith("/blog") || req.path === "/" || req.path.startsWith("/success") || req.path.startsWith("/terms") || req.path.startsWith("/privacy") || req.path.startsWith("/browser") || req.path.startsWith("/referral")) {
    res.set("Cache-Control", "public, max-age=3600, s-maxage=86400");
  } else if (req.path.startsWith("/api")) {
    res.set("Cache-Control", "public, max-age=10, s-maxage=10");
  } else if (req.path.match(/\.(js|css|png|jpg|jpeg|gif|svg|woff|woff2|json)$/i)) {
    res.set("Cache-Control", "public, max-age=31536000, immutable");
  }
  if (req.method === "OPTIONS") {
    return res.sendStatus(200);
  }
  next();
});
app.use((req, res, next) => {
  const start = Date.now();
  const path2 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path2.startsWith("/api")) {
      let logLine = `${req.method} ${path2} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const desiredPort = parseInt(process.env.PORT || "5000", 10);
  let port = desiredPort;
  const maxAttempts = 10;
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      await new Promise((resolve, reject) => {
        const onError = (err) => reject(err);
        server.once("error", onError);
        server.listen({ port, host: "0.0.0.0" }, () => {
          server.removeListener("error", onError);
          log(`Server listening on port ${port}`);
          resolve();
        });
      });
      break;
    } catch (err) {
      const code = err && err.code;
      if (code === "EADDRINUSE" || code === "EACCES") {
        log(`Port ${port} unavailable (${code}). Trying port ${port + 1}...`);
        port += 1;
        if (attempt === maxAttempts - 1) {
          throw new Error(`Could not bind to a port after ${maxAttempts} attempts: ${err?.message || err}`);
        }
        await new Promise((r) => setTimeout(r, 150));
        continue;
      }
      throw err;
    }
  }
})();